#include "elastic.h"

extern Info   info;


/* find boundary conds in list */
static pCl getCl(pMesh mesh,int ref,int elt) {
  pCl     pcl;
  int     i;

  for (i=0; i<mesh->nbcl; i++) {
    pcl = &mesh->cl[i];
    if ( (pcl->ref == ref) && (pcl->elt == elt) )  return(pcl);
  }
  return(0);
}


/* retrieve physical properties in list */
static void getMat(pMesh mesh,int ref,double *lambda,double *mu) {
  pMat   pm;
  int    i;

  *lambda = LS_LAMBDA;
  *mu     = LS_MU;
  for (i=0; i<mesh->nmat; i++) {
    pm = &mesh->mat[i];
    if ( pm->ref == ref ) {
      *lambda = pm->lambda;
      *mu = pm->mu;
      return;
    }
  }
}


/* compute triangle area and unit normal in 3d */
static double area_3d(double *a,double *b,double *c,double *n) {
  double    ux,uy,uz,vx,vy,vz,dd;

  ux = b[0] - a[0];
  uy = b[1] - a[1];
  uz = b[2] - a[2];

  vx = c[0] - a[0];
  vy = c[1] - a[1];
  vz = c[2] - a[2];

  n[0] = uy*vz - uz*vy;
  n[1] = uz*vx - ux*vz;
  n[2] = ux*vy - uy*vx;
  dd   = sqrt(n[0]*n[0] + n[1]*n[1] + n[2]*n[2]);
  if ( dd > EPSD ) {
    dd = 1.0 / dd;
    n[0] *= dd;
    n[1] *= dd;
    n[2] *= dd;
  }

  return(0.5*dd);
}


/* compute volume of tetra */
static double volume(double *a,double *b,double *c,double *d) {
  double  ax,ay,az,bx,by,bz,vol;

  ax = b[0] - a[0];
  ay = b[1] - a[1];
  az = b[2] - a[2];

  bx = c[0] - a[0];
  by = c[1] - a[1];
  bz = c[2] - a[2];

  vol = (d[0]-a[0]) * (ay*bz - az*by) + (d[1]-a[1]) * (az*bx - ax*bz) \
      + (d[2]-a[2]) * (ax*by - ay*bx);
  assert(vol > 0.0);
  return(vol / 6.0);
}


/* invert 3x3 non-symmetric matrix */
static int invmatg(double m[9],double mi[9]) {
  double  aa,bb,cc,det,vmin,vmax,maxx;
  int     k;

  /* check ill-conditionned matrix */
  vmin = vmax = fabs(m[0]);
  for (k=1; k<9; k++) {
    maxx = fabs(m[k]);
    if ( maxx < vmin )  vmin = maxx;
    else if ( maxx > vmax )  vmax = maxx;
  }
  if ( vmax == 0.0 )  return(0);

  /* compute sub-dets */
  aa = m[4]*m[8] - m[5]*m[7];
  bb = m[5]*m[6] - m[3]*m[8];
  cc = m[3]*m[7] - m[4]*m[6];
  det = m[0]*aa + m[1]*bb + m[2]*cc;
  if ( fabs(det) < EPSD )  return(0);
  det = 1.0 / det;

  mi[0] = aa*det;
  mi[3] = bb*det;
  mi[6] = cc*det;
  mi[1] = (m[2]*m[7] - m[1]*m[8])*det;
  mi[4] = (m[0]*m[8] - m[2]*m[6])*det;
  mi[7] = (m[1]*m[6] - m[0]*m[7])*det;
  mi[2] = (m[1]*m[5] - m[2]*m[4])*det;
  mi[5] = (m[2]*m[3] - m[0]*m[5])*det;
  mi[8] = (m[0]*m[4] - m[1]*m[3])*det;

  return(1);
}


int tabEdge(pMesh mesh) {
  pTetra   pt;
  pTria    ptt;
  pPoint   ppt,ppt1,ppt2;
  int      i,j,k,l,ia,ib,hnext,imax,key;
  Edge    *tab;

  tab      = (Edge*)calloc(7*mesh->np+1,sizeof(Edge));
  hnext    = mesh->np;
  mesh->na = 0;

  for (k=1; k<=mesh->ne; k++) {
    pt = &mesh->tetra[k];
  l  = 3;
  for (i=0; i<4; i++) {
    ia = pt->v[i];
    for (j=i+1; j<4; j++) {
      l++;
      ib   = pt->v[j];
    key  = LS_MIN(ia,ib);
    imax = LS_MAX(ia,ib);
    if ( tab[key].ib == 0 ) {
          mesh->na++;
      tab[key].ib = imax;
      tab[key].na = mesh->np + mesh->na;
      pt->v[l]    = mesh->np + mesh->na;
      
      ppt = &mesh->point[mesh->np + mesh->na];
      ppt1 = &mesh->point[ia];
          ppt2 = &mesh->point[ib];
      ppt->c[0]=0.5*(ppt1->c[0]+ppt2->c[0]);
      ppt->c[1]=0.5*(ppt1->c[1]+ppt2->c[1]);
          ppt->c[2]=0.5*(ppt1->c[2]+ppt2->c[2]);
      if (ppt1->ref == ppt2->ref) ppt->ref = ppt1->ref;
    }
    else {
      while ( tab[key].ib != imax && tab[key].nxt ) {
            key = tab[key].nxt;
      }
      if ( tab[key].ib == imax ) {
        pt->v[l] = tab[key].na;
      }
      else {
        mesh->na++;
      hnext++;
      assert(hnext < 7*mesh->np);
        tab[key].nxt  = hnext;
      tab[hnext].ib = imax;
        tab[hnext].na = mesh->np + mesh->na;
      pt->v[l]      = mesh->np + mesh->na;
      
      ppt = &mesh->point[mesh->np + mesh->na];
      ppt1 = &mesh->point[ia];
      ppt2 = &mesh->point[ib];
      ppt->c[0]=0.5*(ppt1->c[0]+ppt2->c[0]);
      ppt->c[1]=0.5*(ppt1->c[1]+ppt2->c[1]);
      ppt->c[2]=0.5*(ppt1->c[2]+ppt2->c[2]);
      if (ppt1->ref == ppt2->ref) ppt->ref=ppt1->ref;

      }
      }
      }
  }
  }
   for (k=1; k<=mesh->nt; k++) {
    ptt = &mesh->tria[k];
  l  = 2;
  for (i=0; i<3; i++) {
    ia = ptt->v[i];
    for (j=i+1; j<3; j++) {
      ib   = ptt->v[j];
    key  = LS_MIN(ia,ib);
    imax = LS_MAX(ia,ib);
    while ( tab[key].ib != imax ) {
      key = tab[key].nxt;
    }
     l++;
     ptt->v[l] = tab[key].na;
    }
  }
 }
  free(tab);
  //printf("mesh->na = %d  < %d\n",mesh->na,7*mesh->np);
  
  for (k=1; k<=mesh->ne; k++) {
    pt = &mesh->tetra[k];
  for (i=4; i<10; i++)  assert(pt->v[i]>mesh->np);  
   }
   
  return(1);
}

static pCsr allocA_3d(pMesh mesh) {
  pCsr     A;
  pTetra   pt;
  int      i,j,k,s,ig,jg,ia,ja,nbc,nbp;

  A = (pCsr)calloc(1,sizeof(Csr));  
  assert(A);
  A->nr  = 3*(mesh->np+mesh->na);
  A->nc  = 3*(mesh->np+mesh->na);

  if ( mesh->info.typelt == P1 ) {
  nbp    = 12;
  }
  else {
  nbp    = 30;
  }
  A->nbe = 0;
  A->typ = CS_UT + CS_SYM;
  A->row = (int*)calloc(A->nr+1,sizeof(int));
  assert(A->row);

  /* count non null elts */
  for (k=1; k<=mesh->ne; k++) {
    pt = &mesh->tetra[k];
    if ( !pt->v[0] )  continue;
    for (i=0; i<nbp; i++) {
      ig = pt->v[i/3];
    s  = 3 - i % 3;
      ia = 3*(ig-1) + i % 3;
      for (j=i+s; j<nbp; j++) {
        jg = pt->v[j/3];
        ja = 3*(jg-1) + j % 3;
        A->row[LS_MIN(ia,ja)] += 1;
      }
    }
  }
 
  /* improve estimate */
  for (k=0; k<3*(mesh->np+mesh->na); k++) {
    nbc = LS_MAX(nbp, A->row[k]); //LS_MAX(nbp, A->row[k]*2.0/3.0 + 3);
    A->row[k] = A->nbe;
  A->nbe   += nbc;
  }
  A->row[k] = A->nbe;

  A->col = (int*)malloc(A->nbe*sizeof(int));
  A->val = (double*)malloc(A->nbe*sizeof(double));
  assert(A->col);
  assert(A->val);
 
  for (i=0; i<A->nbe; i++)  A->col[i] = -1;
  return(A);  
}


static void compactA_3d(pCsr A) {
  int   i,j,k,s,taille;

  A->nbe = -1;
  taille = A->row[1] - A->row[0];
  for (k=0; k<A->nr-1; k++) {
  for (j=A->row[k]+taille-1; j>=A->row[k]; j--)
    if ( A->col[j] > -1 )  break;
  s = j + 1;
    if ( s == A->row[k+1] )  continue;    
    for (i=A->row[k+1]; i<A->row[k+2]; i++) {
    j++; 
    A->val[j] = A->val[i];
    A->val[i] = 0.0;
    A->col[j] = A->col[i];
    A->col[i] = -1;
    }
  taille = A->row[k+2] - A->row[k+1];
    A->row[k+1] = s;
  }
  for (j=A->row[A->nr]-1; j>=A->row[A->nr-1]; j--)
  if ( A->col[j] > -1 )  break;
  A->row[A->nr] = j + 1;

  /* update sizes */
  A->col = (int*)realloc(A->col,(j+1)*sizeof(int));
  A->val = (double*)realloc(A->val,(j+1)*sizeof(double));
  assert(A->col);
  assert(A->val);
}


int elasti1_2d(pMesh mesh,pSol sol) {
  pCsr   A;

  A = csrAlloc(mesh->np,mesh->np,6*mesh->nt+1,1);
    
  return(1);
}

int assMat_P2(pTetra pt,pCsr A,double *DeD,double *im,double vol) {
  double  Ae[30][30],mm[9][30],nn[9][30],Dp[3][10],wp;
  int     i,j,p,s,ia,ja,ic,il,ig,jg;

  static double w[5]    = { -4./5., 9./20., 9./20., 9./20.,  9./20. };
  static double q[5][3] = { {1./4.,1./4.,1./4.}, {1./2.,1./6.,1./6.}, {1./6.,1./2.,1./6.}, 
                         {1./6.,1./6.,1./2.}, {1./6.,1./6.,1./6.} };

  memset(Ae,0,30*30*sizeof(double));

  /* boucle sur les 5 points de quadrature */
  for (p=0; p<5; p++) {

  /* Dp */
  Dp[0][0]=4*q[p][0]-1;   Dp[0][1]=0;              Dp[0][2]=0;             Dp[0][3]=4*(q[p][0]+q[p][1]+q[p][2])-3; 
  Dp[1][0]=0;             Dp[1][1]=4*q[p][1]-1;    Dp[1][2]=0;             Dp[1][3]=4*(q[p][0]+q[p][1]+q[p][2])-3; 
  Dp[2][0]=0;             Dp[2][1]=0;              Dp[2][2]=4*q[p][2]-1;   Dp[2][3]=4*(q[p][0]+q[p][1]+q[p][2])-3; 
    
  Dp[0][4]=4*q[p][1];     Dp[0][5]=4*q[p][2];                         Dp[0][6]=4*(1-2*q[p][0]-q[p][1]-q[p][2]); 
    Dp[1][4]=4*q[p][0];     Dp[1][5]=0;                                 Dp[1][6]=-4*q[p][0]; 
  Dp[2][4]=0;             Dp[2][5]=4*q[p][0];                         Dp[2][6]=-4*q[p][0];   
  
  Dp[0][7]=0;             Dp[0][8]=-4*q[p][1];                        Dp[0][9]=-4*q[p][2];
  Dp[1][7]=4*q[p][2];     Dp[1][8]=4*(1-q[p][0]-2*q[p][1]-q[p][2]);   Dp[1][9]=-4*q[p][2];
  Dp[2][7]=4*q[p][1];     Dp[2][8]=-4*q[p][1];                        Dp[2][9]=4*(1-q[p][0]-q[p][1]-2*q[p][2]);
    
  /* mm = (tBt^-1) Dp */
  memset(mm,0,9*30*sizeof(double));
  for (i=0; i<3; i++) {
    for (j=0; j<10; j++) {
    for (s=0; s<3; s++) 
      mm[i][j]   += im[i*3+s] * Dp[s][j];
      mm[i+3][j+10] = mm[i][j];
    mm[i+6][j+20] = mm[i][j];
    }
  }
   
  /* nn = DeD mm */
  memset(nn,0,9*30*sizeof(double));
  for (i=0; i<9; i++) {
    for (j=0; j<30; j++) {
    for (s=0; s<9; s++)
      nn[i][j] += DeD[i*9+s] * mm[s][j];
    }
  }
  
  /* Ae = vol tmm DeD mm */
  wp = vol * w[p];
  for (i=0; i<30; i++) {
    for (j=i; j<30; j++) {
    for (s=0; s<9; s++)
      Ae[i][j] += wp * mm[s][i] * nn[s][j];
    }
  }
  }
  
  /* stifness matrix */
    for (i=0; i<30; i++) {
      ig = pt->v[i % 10];
      ia = 3*(ig-1) + (i / 10);
      for (j=i; j<30; j++) {
    if ( fabs(Ae[i][j]) < EPSD )  continue;
        jg = pt->v[j % 10];
        ja = 3*(jg-1) + (j / 10);
    il = LS_MIN(ia,ja);
    ic = LS_MAX(ia,ja);
        for (s=A->row[il]; s<A->row[il+1]; s++) {
          if ( A->col[s] == -1 ) {
            A->col[s] = ic;
            A->val[s] = Ae[i][j];
            break;
          }
          else if ( A->col[s] == ic ) {
            A->val[s] += Ae[i][j];
            break;
          }
        }
        assert(s < A->row[il+1]);
      }

    }

  return(1);
}


int assMat_P1(pTetra pt,pCsr A,double *DeD,double *im,double vol) {
  double  Ae[12][12],mm[9][12],nn[9][12],Dp[3][4];
  int     i,j,s,ia,ja,ic,il,ig,jg;
  
  /* Dp */
  Dp[0][0]=1;      Dp[0][1]=0;           Dp[0][2]=0;           Dp[0][3]=-1; 
  Dp[1][0]=0;      Dp[1][1]=1;           Dp[1][2]=0;           Dp[1][3]=-1; 
    Dp[2][0]=0;      Dp[2][1]=0;           Dp[2][2]=1;           Dp[2][3]=-1; 
   
  /* mm = (tBt^-1) Dp */
  memset(mm,0,9*12*sizeof(double));
  for (i=0; i<3; i++) {
    for (j=0; j<4; j++) {
    for (s=0; s<3; s++)
      mm[i][j]   += im[i*3+s] * Dp[s][j];
      mm[i+3][j+4] = mm[i][j];
    mm[i+6][j+8] = mm[i][j];
    }
    }

    /* nn = DeD mm */
    for (i=0; i<9; i++) {
      for (j=0; j<12; j++) {
        nn[i][j] = 0.0;
        for (s=0; s<9; s++)
          nn[i][j] += DeD[i*9+s] * mm[s][j];
      }
    }

  /* Ae = vol tmm nn */
    memset(Ae,0,12*12*sizeof(double));
    for (i=0; i<12; i++) {
      for (j=i; j<12; j++) {
        for (s=0; s<9; s++)
          Ae[i][j] += vol * mm[s][i] * nn[s][j];
      }
    }

    /* stifness matrix */
    for (i=0; i<12; i++) {
      ig = pt->v[i % 4];
      ia = 3*(ig-1) + (i / 4);
      for (j=i; j<12; j++) {
    if ( fabs(Ae[i][j]) < EPSD )  continue;
        jg = pt->v[j % 4];
        ja = 3*(jg-1) + (j / 4);
        if ( ia < ja ) {
          il = ia;
          ic = ja;
        }
        else {
          il = ja;
          ic = ia;
        }
        for (s=A->row[il]; s<A->row[il+1]; s++) {
          if ( A->col[s] == -1 ) {
            A->col[s] = ic;
            A->val[s] = Ae[i][j];
            break;
          }
          else if ( A->col[s] == ic ) {
            A->val[s] += Ae[i][j];
            break;
          }
        }
        assert(s < A->row[il+1]);
      }
    }
  return(1);
}


int elasti1_3d(pMesh mesh,pSol sol) {
  pCsr    A;
  pCl     pcl;
  pTetra  pt;
  pTria   ptt;
  pPoint  ppt;
  double  *B,*v,DeD[81],m[9],im[9],*a,*b,*c,*d;
  double  n[3],w[3],lambda,mu,vol,err,aire,dd;
  int     i,k,ig,nbp,nbpt,nit,ier;
  char    ptcl,tricl,filecl;

  if ( abs(mesh->info.imprim) > 4 )
    fprintf(stdout,"  1.1 ASSEMBLY (%s)\n",mesh->info.typelt==P1 ? "P1" : "P2");

  /* alloc */
  if ( mesh->info.typelt == P2 ) {
    tabEdge(mesh);
  fprintf(stdout,"     %d nodes added.\n",mesh->na);
  nbp = 10;
  nbpt = 6;
  }
  else {
    nbp = 4;
  nbpt = 3;
  }
  
  fprintf(stdout,"     Build matrices\n");  
  A = (pCsr)allocA_3d(mesh);
  B = (double *)calloc(3*(mesh->np+mesh->na),sizeof(double));
  assert(B);
  memset(DeD,0,81*sizeof(double));
  
  for (k=1; k<=mesh->ne; k++) {
    pt = &mesh->tetra[k];
    if ( !pt->v[0] )  continue;

    /* tD E D */
  getMat(mesh,pt->ref,&lambda,&mu);
    DeD[0]  = DeD[40] = DeD[80] = 2*mu + lambda;
    DeD[4]  = DeD[8]  = DeD[36] = DeD[44] = DeD[72] = DeD[76] = lambda;
    DeD[10] = DeD[12] = DeD[20] = DeD[24] = DeD[28] = DeD[30] = mu; 
    DeD[50] = DeD[52] = DeD[56] = DeD[60] = DeD[68] = DeD[70] = mu;

    a = &mesh->point[pt->v[0]].c[0]; 
    b = &mesh->point[pt->v[1]].c[0]; 
    c = &mesh->point[pt->v[2]].c[0]; 
    d = &mesh->point[pt->v[3]].c[0]; 

    /* tB^-1 */
    for (i=0; i<3; i++) {
      m[i+0] = a[i] - d[i];
      m[i+3] = b[i] - d[i];
      m[i+6] = c[i] - d[i];
    }
    if ( !invmatg(m,im) )  return(0);
    vol = volume(a,b,c,d);
  if ( mesh->info.typelt == P1 )
    assMat_P1(pt,A,DeD,im,vol);
  else
    assMat_P2(pt,A,DeD,im,vol);

  /* right-hand side */
  if ( !mesh->info.gravity )  continue;

    dd  = vol/nbp;   // formule de quadrature a modifier eventuellement
    for (i=0; i<nbp; i++) {
      ig  = pt->v[i];
      B[3*(ig-1)+0] += mesh->info.gr[0] * dd;
      B[3*(ig-1)+1] += mesh->info.gr[1] * dd;
      B[3*(ig-1)+2] += mesh->info.gr[2] * dd;
    }

   }
  /* compactify A */
  compactA_3d(A);

  /* boundary cond */
  fprintf(stdout,"     Boundary cond.\n");
  ptcl = tricl = filecl = 0;
  for (k=0; k<mesh->nbcl; k++) {
  pcl = &mesh->cl[k];
  if ( pcl->elt == LS_Vertices )        ptcl  = 1;
  else if ( pcl->elt == LS_Triangles )  tricl = 1;
  if ( pcl->att == 'f' )  filecl = 1;
  }

  if ( !sol->u ) {
  sol->np = mesh->np;
    sol->u  = (double*)M_calloc(3*(mesh->np+mesh->na),sizeof(double),"sol");
    assert(sol->u);
    if ( filecl )
    fprintf(stdout,"  ## DEFAULT NULL VALUE USED.\n");
  }
  
  if ( ptcl ) {
    for (k=1; k<=(mesh->np+mesh->na); k++) {
      ppt = &mesh->point[k];
    if ( !ppt->ref )  continue;
    pcl = getCl(mesh,ppt->ref,LS_Vertices);
    if ( !pcl )  continue;
      else if ( pcl->att == 'v' )
    v = &pcl->u[0];
      else
    v = &sol->u[3*(k-1)];

      if ( pcl->typ == Dirichlet ) {
        B[3*(k-1)+0] = TGV * v[0];
        B[3*(k-1)+1] = TGV * v[1];
        B[3*(k-1)+2] = TGV * v[2];

      csrDiaX(A,3*(k-1)+1,TGV);
      csrDiaX(A,3*(k-1)+2,TGV);
      csrDiaX(A,3*(k-1)+3,TGV);
      }
      else if ( pcl->typ == Load ) {
        B[3*(k-1)+0] += v[0];
        B[3*(k-1)+1] += v[1];
        B[3*(k-1)+2] += v[2];
      }
  }
  }

 if ( tricl ) {
    for (k=1; k<=mesh->nt; k++) {
    ptt = &mesh->tria[k];
  if ( !ptt->v[0] )  continue;
    pcl = getCl(mesh,ptt->ref,LS_Triangles);
    if ( !pcl )  continue;

      if ( pcl->typ == Dirichlet ) {
      for (i=0; i<nbpt; i++) {
        if ( pcl->att == 'v' )
          v = &pcl->u[0];
        else
          v = &sol->u[3*(ptt->v[i]-1)];
      B[3*(ptt->v[i]-1)+0] = TGV * v[0];
          B[3*(ptt->v[i]-1)+1] = TGV * v[1];
          B[3*(ptt->v[i]-1)+2] = TGV * v[2];

        csrDiaX(A,3*(ptt->v[i]-1)+1,TGV);
        csrDiaX(A,3*(ptt->v[i]-1)+2,TGV);
        csrDiaX(A,3*(ptt->v[i]-1)+3,TGV);
      }
      }
      else if ( pcl->typ == Load ) { // formule de quadrature a changer eventuellement
      a = &mesh->point[ptt->v[0]].c[0];
        b = &mesh->point[ptt->v[1]].c[0];
        c = &mesh->point[ptt->v[2]].c[0];
        aire = area_3d(a,b,c,n) / nbpt;

      v = &pcl->u[0];
        if ( pcl->att == 'n' ) {
      w[0] = pcl->u[0] * n[0];
      w[1] = pcl->u[0] * n[1];
      w[2] = pcl->u[0] * n[2];
      v = w;
        }

        for (i=0; i<nbpt; i++) {
          ig  = ptt->v[i];
        if ( pcl->att == 'f' )
          v = &sol->u[3*(ptt->v[i]-1)];    
          B[3*(ig-1)+0] += aire * v[0];
          B[3*(ig-1)+1] += aire * v[1];
          B[3*(ig-1)+2] += aire * v[2];
        }
      }
    }
  }
  
  /* release and alloc memory */
  M_free(mesh->tetra);
  if ( mesh->nt )  M_free(mesh->tria);
  M_free(mesh->point);

  err = sol->res;
  nit = sol->nit;
    switch ( mesh->info.cg ) {
  case 1:
    if ( abs(mesh->info.imprim) > 4 )
      fprintf(stdout,"  1.2 SOLVING (GC)\n");
    ier = csrConjGrad(A,sol->u,B,&err,&nit);
    break;
  case 2:
  default:
    if ( abs(mesh->info.imprim) > 4 )
      fprintf(stdout,"  1.2 SOLVING (PrecondGC)\n");
    ier = csrPrecondGrad(A,sol->u,B,&err,&nit);
    break;
  case 3:
    if ( abs(mesh->info.imprim) > 4 )
      fprintf(stdout,"  1.2 SOLVING (GMRES)\n");
    ier = csrGMRES(A,sol->u,B,&err,&nit,40,1);
    break;
  }
  if ( ier <= 0 ) {
    fprintf(stdout,"  ## SOL NOT CONVERGED: err= %E  nit= %d  ier= %d\n",err,nit,ier);
  }
  else if ( abs(mesh->info.imprim) > 4 )
  fprintf(stdout,"  %%%% CONVERGENCE: err= %E  nit= %5d\n",err,nit);
    
  free(B);
  csrFree(A);
  return(1);
}
